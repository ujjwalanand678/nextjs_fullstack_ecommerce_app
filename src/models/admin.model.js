import mongoose from "mongoose"

const adminSchema = new mongoose.Schema({

  user: {
    type: mongoose.Schema.Types.ObjectId,
    ref: "User",
    required: true,
    unique: true,
  },

  isSuperAdmin: { type: Boolean, default: false },
  permissions: [String],

}, { timestamps: true })

export default mongoose.models.Admin || mongoose.model("Admin", adminSchema)

/*
type:mongoose.Schema.Types.ObjectId=>“This field is not data —it is a pointer to another document’s identity.”
MongoDB documents always have a special primary key: _id: ObjectId("65f1c2e8b4c9...")
An ObjectId is a 12-byte unique identifier generated by MongoDB.
Think of it as a globally unique serial number — not a number, not a string, but a special binary value.
When you write:
user: {
  type: mongoose.Schema.Types.ObjectId,
  ref: "User"
}
you are saying: This field stores the _id of a User document, not the user itself.
We store the identity reference, not the whole human.
Why not embed the full user?
Because users change over time.
it does not load the User schema into the Admin schema.
Nothing gets merged.
Nothing gets copied.
Nothing lives inside the admin document.
It only stores a reference number.

=>When does user data appear inside admin?
Only when you explicitly ask for it: Admin.find().populate("user")
Then Mongoose performs a second query behind the scenes:
1 get admin
2 see the stored ID
3 fetch matching user
4 attach it temporarily in the response

But this is assembled at runtime — not stored that way.
....................................................................
ref: "User"
does not need the actual User model object.

Mongoose stores models in an internal registry:
mongoose.models["User"] = userModel

Later, when you call populate(), it looks up the model by name — like a phonebook, not a variable reference.

So "User" is basically a foreign key label, not a JS dependency.
So ref does not embed schemas.
It only teaches Mongoose how to follow an ID to another document when requested.
....................................................................
Admin profile = authority layer of the platform.
Admin rights are not identity — they are privileges granted to a user.
Keeping it separate prevents permanently mixing moderation power with the core account.

Why not store in User?
Because roles change:
- employee joins company → becomes admin
- leaves company → admin rights removed

The user remains the same human, only permissions change.

permissions[] allows granular control (support, dispute resolution, product moderation)
while isSuperAdmin represents full system authority.

This models power as temporary capability, not permanent identity.
*/